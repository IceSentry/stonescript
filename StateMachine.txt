var utils = new Utils
var collection = new Collection

var combat_distance = 25
var melee_distance = 8
var _is_running = false

var states = ["out_of_combat", "combat_melee", "combat_ranged", "collecting", "casting"]
var out_of_combat = states.IndexOf("out_of_combat")
var combat_melee = states.IndexOf("combat_melee")
var combat_ranged = states.IndexOf("combat_ranged")
var collecting = states.IndexOf("collecting")
var casting = states.IndexOf("casting")

var _state = out_of_combat

func set_state(state)
  _state = states.IndexOf(state)

func transition(state)
  // out_of_combat
  ?state = out_of_combat
    ?foe.distance < combat_distance & !(foe = boss & foe.state = 1)
      return combat_ranged
    :?collection.can_collect()
      return collecting

  // collecting
  :?state = collecting
    ?foe.distance < combat_distance
      return combat_ranged
    ?!collection.can_collect()
      return out_of_combat

  // ranged
  :?state = combat_ranged
    ?foe.distance > combat_distance
      return out_of_combat
    :?foe.distance < melee_distance | foe = immune_to_ranged | foe.armor > 0
      return combat_melee
    :?foe = boss & foe.state = 1
      return out_of_combat
  
  // melee
  :?state = combat_melee
    ?foe.distance > combat_distance
      return out_of_combat
    :?foe = boss & foe.state = 1
      return out_of_combat

  ?ai.idle & foe.distance > combat_distance
    // TODO make it it's own state
    return out_of_combat

  // casting
  // no controlled transitions

  // state unchanged
  return state

func start_casting()
  set_state("casting")

func stop_casting()
  set_state("combat_ranged")

func is_combat()
  return _state = combat_ranged | _state = combat_melee

func state()
  return states[_state]

func update()
  _state = transition(_state)
